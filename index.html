---
layout: default
title: "Safer Spices"
stylesheet: /css/index.css
---

<table>
{% for row in site.data.spice_data %}
    {% if forloop.first %}
        <thead>
		<th>
		<div>
		<div class="label-holder">
			{% include sort_button.html col=0%}
			<label for="filter-label">Label</label>
		</div>
		<input type="text" name="filter-label" id="filter-label" oninput="filterTable()" placeholder="filter...">
		</div>
		</th>
		<th>
		<div>
		<div class="label-holder">
			{% include sort_button.html col=1%}
			<label for="filter-danger">Danger Level</label>
		</div>
		<input type="text" min="0" max="4" name="filter-danger" id="filter-danger" oninput="filterTable()" placeholder="filter...">
		</div>
		</th>
		<th>
		<div>
		<div class="label-holder">
			{% include sort_button.html col=2%}
			<label for="filter-category">Category</label>
		</div>
		<input type="text" name="filter-category" id="filter-category" oninput="filterTable()" placeholder="filter...">
		</div>
		</th>
	</thead>
    {% endif %}
    <tr>
	    <td id="{{row['Label'] | replace: ' ', '-'}}">{{ row['Label'] }}</td>
	<td class="danger-{{ row['Danger Level'] }}">{{ row['Danger Level'] }}</td>
        <td>{{ row['Category'] }}</td>
    </tr>
{% endfor %}
</table>
<script>

function removeExistingHighlights() {
    document.querySelectorAll(".highlight").forEach(highlight => {
        const parent = highlight.parentNode;
        while (highlight.firstChild) {
            parent.insertBefore(highlight.firstChild, highlight);
        }
        parent.removeChild(highlight);
    });
}

function highlightText(textContainer, filter) {
    const textContent = textContainer.textContent || textContainer.innerText;
    const index = textContent.toUpperCase().indexOf(filter.toUpperCase());

    if (index >= 0) {
        let beforeMatch = textContent.substring(0, index);
        let match = textContent.substring(index, index + filter.length);
        let afterMatch = textContent.substring(index + filter.length);
        
        textContainer.innerHTML = 
            beforeMatch +
            "<span class='highlight'>" +
            match +
            "</span>" +
            afterMatch;
    }
}

function filterAndHighlightRow(tr, td, filter) {
    if (td) {
        const txtValue = td.textContent || td.innerText;
        if (txtValue.toUpperCase().indexOf(filter) > -1) {
            tr.style.display = "";
            filter && highlightText(td, filter);
        } else {
            tr.style.display = "none";
        }
    }
}

function filterTable() {
    const table = document.querySelector("table");
    const tr = table.getElementsByTagName("tr");
    const filters = document.querySelectorAll("input[id^='filter-']");

    removeExistingHighlights();

    for (let i = 1; i < tr.length; i++) {
        let tds = tr[i].getElementsByTagName("td");
        let shouldDisplay = true;

        filters.forEach((filterInput, idx) => {
            const filterText = filterInput.value.toUpperCase();
            const td = tds[idx];

            let columnMatches = !filterText || (td && td.textContent.toUpperCase().indexOf(filterText) > -1);
            if (filterText && td) {
                highlightText(td, filterText);
            }

            if (!columnMatches) {
                shouldDisplay = false;
            }
        });

        tr[i].style.display = shouldDisplay ? "" : "none";
    }
}

let sortOrder = 1; // Initialize sort order. 1: ascending, -1: descending

function sortBy(col) {
    const table = document.querySelector("table");
    const tbody = table.getElementsByTagName("tbody")[0];
    const rows = Array.from(tbody.getElementsByTagName("tr"));

    // Toggle sort order
    sortOrder = -sortOrder;

    // Sort rows
    const sortedRows = rows.sort((a, b) => {
        const aText = a.getElementsByTagName("td")[col].innerText || a.getElementsByTagName("td")[col].textContent;
        const bText = b.getElementsByTagName("td")[col].innerText || b.getElementsByTagName("td")[col].textContent;
        return aText.localeCompare(bText, undefined, { numeric: true }) * sortOrder;
    });

    // Append sorted rows
    for (const row of sortedRows) {
        tbody.appendChild(row);
    }

    removeExistingHighlights(); // You might want to remove highlights when sorting
}

</script>

